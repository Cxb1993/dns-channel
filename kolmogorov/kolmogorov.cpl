
! 
! Computes the source term and the geometric space flux
! in the generalized Kolmogorov equation specialized 
! for channel flow, as in Marati, Casciola, Piva, JFM 2004, 
! equation 3.4 and following definitions.
 
! This program IS parallel with distributed memory support

! In order to reduce the computational time, an undersampling factor 
! in x and z directions is introduced and the computation of TDISS, MEAN
! TERMS and scale energy are skipped, as already computed with tke.cpl 
! 

gamma=0
outinterv=0
USE ../dnsdata
USE ../dnsdirect
USE ../tke/convenience
#define DIVERGENCE
!USE rtchecks


! Parameters
! -----------------------------
nfmin=1
nfmax=1
dn=1
us=24	! Undersampling factor in x and z directions
! -----------------------------
INTEGER nftot=[(nfmax-nfmin) DIV dn]+1
INTEGER nx_us=nx DIV us,nz_us=nz DIV us
REAL dxOus=2*PI*us/[alfa0*(2*nx+1)], dzOus=2*PI*us/[alfa0*(2*nx+1)]
INLINE INTEGER FUNCTION izd(INTEGER iz)=IF iz>=0 THEN iz ELSE nzd+iz
rx0=2*PI*us/(2*nx+1)
rz0=2*PI*us/(2*nz+1) 

! Definitions
! -----------------------------
FLUXVEC = STRUCTURE(REAL xx, yy, zz)
SCALEFLUX = STRUCTURE(FLUXVEC TURB, MEAN, VISC)
DIVSCALEFLUX = STRUCTURE(REAL TURB, MEAN, VISC) 
SPACEFLUX = STRUCTURE(REAL TURB, PRES, VISC)
MEANTERMS = STRUCTURE(REAL u,w,Uy,Wy,Uyy,Wyy) ! tke.cpl (with small letters for later convenience)
TKETERMS = STRUCTURE(REAL PROD,PDISS,TDIFF,PDIFF,VDIFF,PHI_TDIFF,PHI_PDIFF,PHI_VDIFF) ! tke.cpl
MKETERMS = STRUCTURE(REAL MPROD,TPROD,TMDIF,MMDIF,DISSu,DISSw,PHI_TMDIF,PHI_MMDIF) ! tke.cpl

ARRAY(nyl-2..nyh+2,0..nx_us,-nz_us..nz_us) OF REAL scalePROD=0
ARRAY(nyl-2..nyh+2) OF REAL scaleDISS=0
ARRAY(nyl-2..nyh+2,0..nx_us,-nz_us..nz_us) OF REAL scaleENER=0
ARRAY(nyl-2..nyh+2,0..nx_us,-nz_us..nz_us) OF SPACEFLUX phiC=0
ARRAY(nyl-2..nyh+2,0..nx_us,-nz_us..nz_us) OF SCALEFLUX phiR=0
#ifdef DIVERGENCE
ARRAY(nyl-2..nyh+2,0..nx_us,-nz_us..nz_us) OF DIVSCALEFLUX DIVphiR=0
#endif
ARRAY(nyl-2..nyh+2) OF MEANTERMS meandata=0

ARRAY(0..nx,-nz..nz,nyl-2..nyh+2) OF COMPLEX pressure=0
ARRAY(0..nx,-nz..nz,nyl-2..nyh+2) OF DERIVS Vder=0

USE ../energy-box/poisson_solver_parallel

POINTER TO STORED STRUCTURE[
	ARRAY(-1..ny+1,0..nx_us,-nz_us..nz_us) OF REAL scalePRODimage
        ARRAY(-1..ny+1) OF REAL scaleDISSimage
	ARRAY(-1..ny+1,0..nx_us,-nz_us..nz_us) OF REAL scaleENERimage
] sourceimage

POINTER TO STORED STRUCTURE[
	ARRAY(-1..ny+1,0..nx_us,-nz_us..nz_us) OF SCALEFLUX phiRimage
	ARRAY(-1..ny+1,0..nx_us,-nz_us..nz_us) OF DIVSCALEFLUX DIVphiRimage
] fluximage

POINTER TO STORED ARRAY(-1..ny+1,0..nx_us,-nz_us..nz_us) OF SPACEFLUX phiCimage

! FD for derivatives
! ------------------------------
#define dx0(f) [-3/2*Vder(0,iz,iy).f.REAL + 2*Vder(1,iz,iy).f.REAL - 1/2*Vder(2,iz,iy).f.REAL]/dxOus 
#define dxn(f) [3/2*Vder(nx_us,iz,iy).f.REAL - 2*Vder(nx_us-1,iz,iy).f.REAL + 1/2*Vder(nx_us-2,iz,iy).f.REAL]/dxOus
#define dx(f)  [Vder(ix+1,iz,iy).f.REAL - Vder(ix-1,iz,iy).f.REAL]/(2*dxOus) 
#define dz0(f) [-3/2*Vder(ix,-nz_us,iy).f.REAL + 2*Vder(ix,-nz_us+1,iy).f.REAL - 1/2*Vder(ix,-nz_us+2,iy).f.REAL]/dzOus
#define dzn(f) [3/2*Vder(ix,nz_us,iy).f.REAL - 2*Vder(ix,-nz_us-1,iy).f.REAL + 1/2*Vder(ix,-nz_us-2,iy).f.REAL]/dzOus
#define dz(f)  [Vder(ix,iz+1,iy).f.REAL - Vder(ix,iz-1,iy).f.REAL]/(2*dzOus) 

! Load MEANTERMS and TKETERMS
! ------------------------------
POINTER TO STORED STRUCTURE[
        ARRAY(-1..ny+1) OF MEANTERMS meandataimage
        ARRAY(-1..ny+1) OF TKETERMS tkedataimage
        ARRAY(-1..ny+1) OF MKETERMS mkedataimage
] tkeimage

IF NOT first THEN READ FROM prev
        tkeimage=OPEN("tke.bin")
        WITH tkeimage: meandata=meandataimage(nyl-2..nyh+2); scaleDISS=-4*tkedataimage(nyl-2..nyh+2).PDISS
        CLOSE(tkeimage)
IF NOT last THEN WRITE TO next

IF has_terminal THEN WRITE "Computing Kolmogorov Equation: go get a coffee..."
! Compute Kolmogorov Equation
! -------------------------------
LOOP files FOR if=nfmin TO nfmax BY dn
        ! Loading data
        STRING field_name = WRITE("Field"if".fld")
        read_field_parallel(field_name)
        ! Derivatives and pressure
        compute_pressure(Vder,pressure)
        ! scalePROD, scaleENER, phiC.PRES
        LOOP planes FOR iy=nyl-2 TO nyh +2 
        WRITE iy
                LOOP FOR ialfa=0 TO nx 
                   c=IF ialfa=0 THEN 1 ELSE 2
                   LOOP FOR ibeta=-nz TO nz WITH V(ialfa,ibeta,iy):
			uv=v|u; uu=u|u; vv=v|v; ww=w|w; pv=v|pressure(ialfa,ibeta,iy)
                	LOOP FOR ix=0 TO nx_us
                        	LOOP FOR iz=-nz_us TO nz_us WITH phiC(iy,ix,iz),meandata(iy):
                                         COMPLEX E = I*ialfa*rx0*ix+I*ibeta*rz0*iz 
                                         E = c*(2-EXP(E)-EXP(-E)); 
	          scalePROD(iy,ix,iz)      = ~ + [ E * uv ].REAL * -2*Uy
                       PRES                = ~ + [ E * pv ].REAL *  2
                  scaleENER(iy,ix,iz)      = ~ + [ E * (uu + vv + ww) ].REAL
                                REPEAT     
                        REPEAT
		   REPEAT
                REPEAT
        ! phiC.TURB (pseudo-spectral)
		LOOP FOR irx=0 TO nx_us
                        rx = rx0*irx
			LOOP FOR irz=-nz_us TO nz_us 
                                WITH VVd(*,*,0): uu=0; vv=0; ww=0; uv=0; 
                                rz = rz0*irz
				LOOP FOR ialfa=0 TO nx
					LOOP FOR ibeta=-nz TO nz WITH V(ialfa,ibeta,iy):
                                          ibetad = izd(ibeta)
                                          E    = I*ialfa*rx/2+I*ibeta*rz/2
                                          E_2  =     [EXP(E)-EXP(-E)];
                                          E_2s = 0.5*[EXP(E)+EXP(-E)]; 
	                VVd(ialfa,ibetad,0).uu = E_2*u    !du
                        VVd(ialfa,ibetad,0).vv = E_2*v    !dv
	                VVd(ialfa,ibetad,0).ww = E_2*w    !dw
	                VVd(ialfa,ibetad,0).uv = E_2s*v   !vstar
					REPEAT
				REPEAT		 						
                                DO WITH VVd(ix,*,0): IFT(uu); IFT(vv); IFT(ww); IFT(uv) FOR ALL ix
                                DO WITH VVd(*,iz,0): 
                                   RFT(uu); RFT(vv); RFT(ww); RFT(uv) 
                                   DO WITH VVd(ix,iz,0):
                                     uw.REAL = [uu.REAL*uu.REAL+vv.REAL*vv.REAL+ww.REAL*ww.REAL]*(uv.REAL)
                                     uw.IMAG = [uu.IMAG*uu.IMAG+vv.IMAG*vv.IMAG+ww.IMAG*ww.IMAG]*(uv.IMAG)
                                   FOR ALL ix
                                   WITH VVd(*,iz,0): HFT(uw);
                                FOR ALL iz
                                DO WITH VVd(ix,*,0): FFT(uw) FOR ALL ix
                                WITH phiC(iy,irx,irz),VVd(0,0,0): TURB = ~+uw.REAL;
			REPEAT
		REPEAT	
        ! scaleENERr, scale_turb and scale_mean
          IF iy>=nyl AND iy<=nyh THEN
                Vder.ux=0 ! Vder.ux.REAL=scaleENERr must be recomputed every iy, need to be erased
                Vry==V(ialfa,ibeta,iry)
                Vyc==V(ialfa,ibeta,iy)
                meandata.u=V(0,0,*).u.REAL; meandata.w=V(0,0,*).w.REAL; V(0,0,*)=0 ! This block needs V(0,0)=0
        	LOOP FOR iry=iy-2 TO iy+2
                        deltameanU = meandata(iry).u-meandata(iy).u
                        deltameanW = meandata(iry).w-meandata(iy).w
                	LOOP FOR irx=0 TO nx_us
                           rx=rx0*irx
                           LOOP FOR irz=-nz_us TO nz_us 
                                rz=irz*rz0
                                VVd=0; Vd=0 ! They must be recomputed every (irx,irz), need to be erased
                                LOOP FOR ibeta=-nz TO nz
                                  ibetad = izd(ibeta); 
                                  LOOP FOR ialfa=0 TO nx AND ibeta=-nz TO nz
                                     c=IF ialfa=0 THEN 1 ELSE 2
                                     E = EXP(I*ialfa*rx+I*ibeta*rz)
                                     Vder(irx,irz,iry).ux.REAL =~+c*[NORM(Vry.u)+NORM(Vyc.u)-2*(Vyc.u|Vry.u)*E+
                                                                     NORM(Vry.v)+NORM(Vyc.v)-2*(Vyc.v|Vry.u)*E+
                                                                     NORM(Vry.w)+NORM(Vyc.w)-2*(Vyc.w|Vry.w)*E].REAL   ! scaleENERr XXX (also pseudo-spectrally?)
                                     Vd(ialfa,ibetad).u=Vry.u*E - Vyc.u ! delta_mean.u
                                     Vd(ialfa,ibetad).v=Vry.v*E - Vyc.v ! delta_mean.v
                                     Vd(ialfa,ibetad).w=Vry.w*E - Vyc.w ! delta_mean.w
                                  REPEAT
                                REPEAT
                                DO WITH Vd(ix,*): IFT(u); IFT(v); IFT(w)  FOR ALL ix  
                                DO WITH Vd(*,iz): 
                                   RFT(u); RFT(v); RFT(w);
				   DO WITH Vd(ix,iz): 
                                     uvw_r = [u.REAL^2 + v.REAL^2 + w.REAL^2]
                                     uvw_i = [u.IMAG^2 + v.IMAG^2 + w.IMAG^2]
	                             VVd(ix,iz,1).uu.REAL = uvw_r * u.REAL;     VVd(ix,iz,1).uu.IMAG = uvw_i * u.IMAG !deltad_turb.u  
	                             VVd(ix,iz,1).vv.REAL = uvw_r * v.REAL;     VVd(ix,iz,1).vv.IMAG = uvw_i * v.IMAG !deltad_turb.v  
	                             VVd(ix,iz,1).ww.REAL = uvw_r * w.REAL;     VVd(ix,iz,1).ww.IMAG = uvw_i * w.IMAG !deltad_turb.w 
                                     VVd(ix,iz,2).uu.REAL = uvw_r * deltameanU; VVd(ix,iz,2).uu.IMAG = uvw_i * deltameanU   !deltad_mean.u
                                     VVd(ix,iz,2).ww.REAL = uvw_r * deltameanW; VVd(ix,iz,2).ww.IMAG = uvw_i * deltameanW   !deltad_mean.w
				   FOR ALL ix
                                   WITH VVd(*,iz,1): HFT(uu); HFT(vv); HFT(ww); WITH VVd(*,iz,2): HFT(uu); HFT(ww)  
                                FOR ALL iz
                                DO WITH VVd(ix,*,1): FFT(uu); FFT(vv); FFT(ww); WITH VVd(ix,*,2): FFT(uu); FFT(ww) FOR ALL ix   
                                WITH Vder(irx,irz,iry): 
                                   uy.REAL=VVd(0,0,1).uu.REAL; vy.REAL=VVd(0,0,1).vv.REAL; wy.REAL=VVd(0,0,1).ww.REAL; ! scale_turb(xx,yy,zz)
                                   uz.REAL=VVd(0,0,2).uu.REAL; wz.REAL=VVd(0,0,2).ww.REAL; ! scale_mean(xx,yy,zz)
                           REPEAT  
                        REPEAT
                REPEAT
                V(0,0,*).u.REAL=meandata(*).u; V(0,0,*).w.REAL=meandata(*).w;
	        DO WITH derivs_standalone(iy):
                     rx = ix*rx0; rz = iz*rz0
                     WITH phiR(iy,ix,iz).TURB, Vder(ix,iz,iy): xx =~+uy.REAL; yy =~+vy.REAL; zz =~+wy.REAL ! scale_turb(xx,yy,zz)
                     WITH phiR(iy,ix,iz).MEAN, Vder(ix,iz,iy): xx =~+uz.REAL; zz =~+wz.REAL                ! scale_mean(xx,yy,zz)        
                     WITH phiR(iy,ix,iz).VISC: yy = ~ -2*ni*D1(Vder(ix,iz,iy+(-2..2)).ux.REAL)             ! Vder.ux.REAL==scaleENERr
#ifdef DIVERGENCE
                     DIVphiR(iy,ix,iz).VISC = ~ -2*ni*D2(Vder(ix,iz,iy+(-2..2)).ux.REAL) ! Vder.ux.REAL==scaleENERr
                     DIVphiR(iy,ix,iz).TURB = ~ +D1(Vder(ix,iz,iy+(-2..2)).vy.REAL)      ! Vder.vy.REAL==scaleTURB
#endif
                     LOOP FOR ialfa=0 TO nx AND ibeta=-nz TO nz WITH V(ialfa,ibeta,iy):
                       E = EXP(I*ialfa*rx+I*ibeta*rz); uu_vv_ww_E = [NORM(u) + NORM(v) + NORM(w)]*E
		       WITH phiR(iy,ix,iz).VISC:
                          C = IF ialfa=0 THEN 4 ELSE 8
		         xx = ~ +C*ni*[I*alfa0*ialfa*uu_vv_ww_E].REAL
		         zz = ~ +C*ni*[I*beta0*ibeta*uu_vv_ww_E].REAL ! XXX Can this be merged with scaleENER?
#ifdef DIVERGENCE
     DIVphiR(iy,ix,iz).VISC = ~ -C*ni*{[uu_vv_ww_E*(alfa0*ialfa)**2].REAL+[uu_vv_ww_E*(beta0*ibeta)**2].REAL}
#endif
                     REPEAT
#ifdef DIVERGENCE
                     WITH DIVphiR(iy,ix,iz):
                     IF ix=0 THEN TURB=~+dx0(uy); MEAN=~+dx0(uz) ELSE IF ix=nx_us THEN TURB=~+dxn(uy); MEAN=~+dxn(uz) ELSE TURB=~+dx(uy);  MEAN=~+dx(uz) END IF
                     IF iz=-nz_us THEN TURB=~+dz0(wy); MEAN=~+dz0(wz) ELSE IF iz=nz_us THEN TURB=~+dzn(wy); MEAN=~+dzn(wz) ELSE TURB=~+dz(wy);  MEAN=~+dz(wz) END IF
#endif
		FOR ix=0 TO nx_us AND iz=-nz_us TO nz_us
          END IF 
        REPEAT planes
REPEAT files

! Ensemble averaging (phiC,scalePROD,scaleENER)
! ----------------------------
WITH phiC: scalePROD=~/nftot; scaleENER=~/nftot; PRES=~/nftot; TURB=~/nftot;
WITH phiR: 
           TURB.xx=~/nftot; TURB.yy=~/nftot; TURB.zz=~/nftot; 
           VISC.xx=~/nftot; VISC.yy=~/nftot; VISC.zz=~/nftot; 
           MEAN.xx=~/nftot; MEAN.yy=~/nftot; MEAN.zz=~/nftot; 
#ifdef DIVERGENCE
WITH DIVphiR: MEAN=~/nftot; TURB=~/nftot; VISC=~/nftot
#endif

! Caompute terms which need final differentiation (phiC.VISC)
! ----------------------------		
DO WITH phiC(*,ix,iz),V(0,0,*): 
  deriv(scaleENER(*,ix,iz),v.REAL); FlushStep1; LeftLUDivStep2(v.REAL,D0mat); FlushStep2
  VISC = ~ - ni/2 * v.REAL
FOR ix=0 TO nx_us AND iz=-nz_us TO nz_us 

! Saving to disk
! ----------------------------
IF has_terminal THEN WRITE "Saving results to disk..."
IF NOT first THEN READ FROM prev
	sourceimage=OPEN("source.dat")
	LOOP FOR iy=miny TO maxy WITH sourceimage:
		scalePRODimage(iy)=scalePROD(iy)
                scaleDISSimage(iy)=scaleDISS(iy)
		scaleENERimage(iy)=scaleENER(iy)
	REPEAT
	CLOSE sourceimage
	phiCimage=OPEN("phiC.dat")
	LOOP FOR iy=miny TO maxy
		phiCimage(iy) = phiC(iy)
	REPEAT
	CLOSE phiCimage
	fluximage=OPEN("phiR.dat")
	LOOP FOR iy=miny TO maxy WITH fluximage:
		phiRimage(iy) = phiR(iy)
#ifdef DIVERGENCE
             DIVphiRimage(iy) = DIVphiR(iy)
#endif
	REPEAT
	CLOSE fluximage
IF NOT last THEN WRITE TO next
