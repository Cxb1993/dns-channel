!
! fast but highly memory demanding version of gke-complete.cpl,
! this program is parallel with shared-memory support only
!
! see gke-complete.cpl for further comments
!

gamma=0
USE ../dnsdata
USE ../dnsdirect
USE ../tke/convenience
!USE rtchecks

! Parameters
! -----------------------------
nfmin=1001
nfmax=1001
dn=1
! -----------------------------
INTEGER nftot=[(nfmax-nfmin) DIV dn]+1
ARRAY(-nz..nz) OF INTEGER izdV=0; DO izdV(iz)=IF iz>=0 THEN iz ELSE nzd+iz FOR iz=-nz TO nz
nxc=(2*nxd) DIV 2; nzc=nzd DIV 2; izd==izdV(iz)

! Definitions
! -----------------------------
GKETERMS = STRUCTURE(ARRAY(1..3) OF REAL rTURB, rMEAN, rVISC; REAL cTURB, cPRES, cVISC, scaleENER, scalePROD)
MEANTERMS = STRUCTURE(REAL U,W,Uy,Wy,Uyy,Wyy) ! uiuj.cpl XXX add pressure in meanterms
MKETERMS = STRUCTURE(REAL pump,produv,prodvw,ttrsp,vdiff,dissU,dissW,PHIttrsp,PHIvdiff) ! uiuj.cpl
BALANCE = STRUCTURE(ARRAY(1..6) OF REAL var,prod,psdiss,ttrsp,vdiff,pstrain,ptrsp,PHIttrsp,PHIvdiff,PHIptrsp) ! uiuj.cpl

INTEGER startpos(-1..ny DIV 2 +1)=0
DO startpos(iy+1)=startpos(iy)+(ny-2*iy+1) FOR iy=-1 TO ny DIV 2
SHARED ARRAY(-1..ny+1) OF MEANTERMS mean
SHARED ARRAY(-1..ny+1) OF BALANCE uiuj
SHARED ARRAY(0..startpos(ny DIV 2 +1)-1,0..nxc-1,0..nzc-1) OF GKETERMS gke=0
SHARED ARRAY(1..2,1..2,0..nxd-1,0..nzd-1) OF STRUCTURE(COMPLEX UU,VV,WW,UV,PV,uuu,uuv,uuw,vvu,vvv,vvw,wwu,wwv,www,uvu,uvv,uwu,uww,vwv,vww) R=0

SHARED ARRAY(0..nx,-nz..nz,nyl-2..nyh+2) OF COMPLEX p=0
POINTER TO ARRAY(0..nx,-nz..nz,nyl-2..nyh+2) OF DERIVS Vder

USE ../energy-box/poisson_solver_parallel
POINTER TO STORED ARRAY(0..startpos(ny DIV 2 +1)-1,0..nxc-1,0..nzc-1) OF GKETERMS gkedata

! Load MEANTERMS and BALANCE
! ------------------------------
POINTER TO STORED STRUCTURE[
        ARRAY(-1..ny+1) OF MEANTERMS meandata
        ARRAY(-1..ny+1) OF MKETERMS mkedata
        ARRAY(-1..ny+1) OF BALANCE uiujdata
] uiujimage
uiujimage=OPEN("uiuj.bin"); WITH uiujimage: mean=meandata; uiuj=uiujdata; CLOSE(uiujimage)

#define pR(A,f) A(*,iz).f.REALIFIED(ix)
#define mR(A,f) A(*,nzd-1-iz).f.REALIFIED(2*nxd-1-ix)
#define R0(A,f) A(*,0).f.REALIFIED(0)
INLINE FUNCTION gkei(INTEGER i,j)=gke(startpos(i)+j-i,ix,iz)
IF has_terminal THEN WRITE "Will require " SIZEOF(ARRAY(0..startpos(ny DIV 2 +1)-1,0..nxc-1,0..nzc-1) OF GKETERMS)/(1024.0**3) " GiB on disk..."
IF has_terminal THEN WRITE "Computing Kolmogorov Equation..."
! Compute Kolmogorov Equation
! -------------------------------
LOOP files FOR if=nfmin TO nfmax BY dn
        ! Cleaning stdout
        IF if>nfmin THEN <*printf("\r                                            \r");*> END IF
        ! Loading data
        STRING field_name = WRITE("Field"if".fld")
        read_field_parallel(field_name)
        ! Derivatives and pressure
        NEW Vder; Vder=0; compute_pressure(Vder,p); FREE(Vder)
        ! Compute fluctuating field (XXX TODO pressure should be put in mean and subtraced here)
        WITH mean(*),V(0,0,*): u.REAL=~-U; w.REAL=~-W; p(0,0,*)=0
        ! Start computation of correlations
        PARALLEL LOOP FOR ismp=0 TO nsmp-1
        LOOP outer FOR iy1=-1 TO ny+1
          IY1 = IF iy1>ny DIV 2 THEN ny-iy1 ELSE iy1; sig = IF iy1>ny DIV 2 THEN -1 ELSE 1
        ! Output progress
          IF ismp=0 THEN INTEGER waitbar=100*(iy1+1)DIV(ny+1); <*printf("\r %d %% completed          ",waitbar_); fflush(stdout);*>
        ! Compute pseudo-spectral correlations
          convolutions(V(*,*,iy1),VVd(*,*,1))
          LOOP inner FOR IY2=IY1 TO ny-IY1
            iy2 = IF iy1>ny DIV 2 THEN ny-IY2 ELSE IY2
            convolutions(V(*,*,iy2),VVd(*,*,2));
            LOOP FOR i1=1 TO 2 AND i2=1 TO 2
              j1=IF i1=1 THEN iy1 ELSE iy2; j2=IF i2=1 THEN iy1 ELSE iy2
              LOOP FOR ix=ismp*(nx+1) DIV nsmp TO (ismp+1)*(nx+1) DIV nsmp -1
                R(i1,i2,ix,nz+1..nzd-nz-1)=0
                DO WITH V(ix,iz,*), VVd(ix,izd,*), R(i1,i2,ix,izd):
                  UU=u(j1)|u(j2);   VV=v(j1)|v(j2);   WW=w(j1)|w(j2);   UV=u(j1)|v(j2);   PV=p(ix,iz,j1)|v(j2);
                  uuu=uu(i1)|u(j2); uuv=uu(i1)|v(j2); uuw=uu(i1)|w(j2); vvu=vv(i1)|u(j2); vvv=vv(i1)|v(j2); vvw=vv(i1)|w(j2);
                  wwu=ww(i1)|u(j2); wwv=ww(i1)|v(j2); www=ww(i1)|w(j2); uvu=uv(i1)|u(j2); uvv=uv(i1)|v(j2); uwu=uw(i1)|u(j2);
                  uww=uw(i1)|w(j2); vwv=vw(i1)|v(j2); vww=vw(i1)|w(j2);
                FOR iz=-nz TO nz
                WITH R(i1,i2,ix,*):  INLINE LOOP FOR iii IN (UU,VV,WW,UV,PV,uuu,uuv,uuw,vvu,vvv,vvw,wwu,wwv,www,uvu,uvv,uwu,uww,vwv,vww); IFT(iii); REPEAT
              REPEAT LOOP
              IF ismp=0 THEN R(i1,i2,nx+1..nxd-1)=0
              SYNC(ismp,nsmp)
              DO WITH R(i1,i2,*,iz):
                INLINE LOOP FOR iii IN (UU,VV,WW,UV,PV,uuu,uuv,uuw,vvu,vvv,vvw,wwu,wwv,www,uvu,uvv,uwu,uww,vwv,vww); RFT(iii); REPEAT
              FOR iz=ismp*nzd DIV nsmp TO (ismp+1)*nzd DIV nsmp -1
            REPEAT
            SYNC(ismp,nsmp)
        ! Compute GKE terms
#define Rturb(f,g) ( pR(R(1,2),f) - mR(R(2,1),f) + 2*pR(R(1,2),g) - 2*mR(R(2,1),g) + R0(R(2,2),f) - R0(R(1,1),g) )
#define Cturb(f,g) ( pR(R(1,2),f) + mR(R(2,1),f) - 2*pR(R(1,2),g) - 2*mR(R(2,1),g) + R0(R(2,2),f) + R0(R(1,1),g) )
#define Rsum(f)    ( R0(R(2,2),f) + R0(R(1,1),f) -   pR(R(1,2),f) -   mR(R(2,1),f) )
            DO WITH gkei(IY1,IY2), mean(*), uiuj(*):
              rTURB(1) = ~+     Rturb(uuu,uuu) + Rturb(vvu,uvv) + Rturb(wwu,uww)
              rTURB(2) = ~+sig*[Rturb(uuv,uvu) + Rturb(vvv,vvv) + Rturb(wwv,vww)]
              rTURB(3) = ~+     Rturb(uuw,uwu) + Rturb(vvw,vwv) + Rturb(www,www)
              iscaleENER = Rsum(UU)+Rsum(VV)+Rsum(WW); scaleENER = ~+iscaleENER
              rMEAN(1) = ~+iscaleENER*[ U(iy2)-U(iy1) ]; rMEAN(2) = 0; rMEAN(3) = ~+iscaleENER*[ W(iy2)-W(iy1) ]
              cTURB = ~+0.5*sig*[ Cturb(uuv,uvu)+Cturb(vvv,vvv)+Cturb(wwv,vww) ]; cPRES = ~+2*sig*[ Rsum(PV) ]
              scalePROD = ~-[ Rsum(UV) ]*[Uy(iy1)+Uy(iy2)]-[SUM psdiss(iy1,i)+psdiss(iy2,i) FOR i=1 TO 3]
            FOR ix=ismp*nxc DIV nsmp TO (ismp+1)*nxc DIV nsmp -1 AND iz=0 TO nzc-1
        ! phiR.rVISC.(xx,zz) requires derivatives in homogeneous directions of scaleENER
            DO
              DO Vd(*,iz).v.REALIFIED(ix)=Rsum(UU)+Rsum(VV)+Rsum(WW) FOR ix=0 TO 2*nxd-1
              WITH Vd(*,iz): HFT(v)
            FOR iz=ismp*nzd DIV nsmp TO (ismp+1)*nzd DIV nsmp -1
            SYNC(ismp,nsmp)
            DO
              WITH Vd(ix,*): FFT(v)
              Vd(ix,nz+1..nzd-nz-1)=0; DO WITH Vd(ix,izd): u=I*alfa0*ix*v;  w=I*beta0*iz*v FOR iz=-nz TO nz
              WITH Vd(ix,*): IFT(u); IFT(w)
            FOR ix=ismp*(nx+1) DIV nsmp TO (ismp+1)*(nx+1) DIV nsmp -1
            IF ismp=0 THEN Vd(nx+1..nxd-1)=0
            SYNC(ismp,nsmp)
            DO WITH Vd(*,iz): RFT(u); RFT(w) FOR iz=ismp*nzd DIV nsmp TO (ismp+1)*nzd DIV nsmp -1
            SYNC(ismp,nsmp)
            DO
              DO WITH gkei(IY1,IY2): rVISC(1) = ~-2*ni*Vd(*,iz).u.REALIFIED(ix); rVISC(3) = ~-2*ni*Vd(*,iz).w.REALIFIED(ix) FOR iz=0 TO nzc-1
            FOR ix=ismp*nxc DIV nsmp TO (ismp+1)*nxc DIV nsmp -1
            SYNC(ismp,nsmp)
          REPEAT inner
        REPEAT outer
        REPEAT
REPEAT files
<*printf("\r                                            \r");*>

! Average
! -------------------------------
DO WITH gke(startpos(IY1)+(0..ny-2*IY1),*,*):
  INLINE LOOP FOR i IN (rTURB,rMEAN,rVISC,cTURB,cPRES,scaleENER,scalePROD) i=~*[IF IY1=ny DIV 2 THEN 1 ELSE 0.5]/nftot; REPEAT
FOR IY1=-1 TO ny DIV 2

IF has_terminal THEN WRITE "Computing y-derivatives..."
INLINE FUNCTION gkeiy2(INTEGER i,j)=(IF j<i THEN gkei(j,i) ELSE IF j>ny-i THEN gkei(ny-j,ny-i) ELSE gkei(i,j))
INLINE FUNCTION gkeiy1(INTEGER i,j)=(IF i>ny DIV 2 THEN gkeiy2(ny-i,ny-j) ELSE gkeiy2(i,j))
! Derive final terms
! -------------------------------
PARALLEL LOOP FOR ismp=0 TO nsmp-1
LOOP derivatives FOR ix=0 TO nxc-1
        IF ismp=0 THEN INTEGER waitbar=100*(ix)DIV(nxc-1); <*printf("\r %d %% completed          ",waitbar_); fflush(stdout);*>
        LOOP FOR iz=ismp*nzc DIV nsmp TO (ismp+1)*nzc DIV nsmp -1
          ! y2-derivatives
          LOOP FOR IY1=-1 TO ny DIV 2
            LOOP FOR IY2=IY1 TO ny-IY1
              j=[IF IY2=-1 THEN 2 ELSE IF IY2=0 THEN 1 ELSE IF IY2=ny THEN -1 ELSE IF IY2=ny+1 THEN -2 ELSE 0]
              WITH derivs_standalone(IY2), gkei(IY1,IY2):
                cVISC   =~-[SUM 0.5*ni*d1(i)*gkeiy2(IY1,IY2+i+j).scaleENER FOR i=-2 TO 2]
                rVISC(2)=~-[SUM ni*d1(i)*gkeiy2(IY1,IY2+i+j).scaleENER FOR i=-2 TO 2]
                rMEAN(2)=~+[SUM 0.5*d1(i)*gkeiy2(IY1,IY2+i+j).rTURB(2) - 0.5*ni*d2(i)*gkeiy2(IY1,IY2+i+j).scaleENER FOR i=-2 TO 2]
            REPEAT
          REPEAT
          ! y1-derivatives
          LOOP FOR IY1=-1 TO ny DIV 2
            j=[IF IY1=-1 THEN 2 ELSE IF IY1=0 THEN 1 ELSE IF IY1=ny THEN -1 ELSE IF IY1=ny+1 THEN -2 ELSE 0]
            LOOP FOR IY2=IY1 TO ny-IY1
              WITH derivs_standalone(IY1), gkei(IY1,IY2):
                rMEAN(2)=~+[SUM d1(i)*(gkeiy1(IY1+i+j,IY2).rVISC(2)-0.5*gkeiy1(IY1+i+j,IY2).rTURB(2))-0.5*ni*d2(i)*gkeiy1(IY1+i+j,IY2).scaleENER FOR i=-2 TO 2]
                cVISC   =~-[SUM 0.5*ni*d1(i)*gkeiy1(IY1+i+j,IY2).scaleENER FOR i=-2 TO 2]
                rVISC(2)=~+[SUM ni*d1(i)*gkeiy1(IY1+i+j,IY2).scaleENER FOR i=-2 TO 2]
            REPEAT
          REPEAT
        REPEAT
REPEAT derivatives
REPEAT
<*printf("\r                                            \r");*>

! Save data to disk
! -------------------------------
gkedata=OPEN("gke-complete.bin")
gkedata(*,*,*)=gke(*,*,*)
CLOSE(gkedata)
